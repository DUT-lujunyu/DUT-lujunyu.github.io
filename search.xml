<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>排序（一）：简单排序：插入排序 &amp;&amp; 冒泡排序</title>
    <url>/2021/09/19/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>leetcode：<a href="https://leetcode-cn.com/problems/sort-an-array/">https://leetcode-cn.com/problems/sort-an-array/</a></p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>插入排序的过程分为两步：</p>
<ul>
<li>首先和当前位置的前一个元素进行比较，如果前一个元素比当前元素大，则后续进行调整，将前面的大元素不断向后移动，并找到合适的位置将当前元素插入进去；</li>
<li>如果发现前一个元素比当前元素小，则不会进行调整，默认前面的元素已经有序。</li>
</ul>
<p>示意图如下：</p>
<img src="https://pic2.zhimg.com/v2-f87ad7d8ad54379dd81f02fcf9b91f49_b.webp" alt="img" style="zoom:80%;"/>

<p><strong>插入排序的特点是：基于比较、数据移动完成排序，一次比较操作后不发生数据移动或仅仅交换一对相邻的数据元素。</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(j = i-<span class="number">2</span>; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp; j--)&#123;</span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>基于这样的过程我们很容易分析插入排序算法的最好情况和最坏情况。</p>
<ul>
<li>最好情况：元素升序有序。那么我们只需要进行 n-1 次元素比较，0次元素移动即可。</li>
<li>最坏情况：元素降序有序。那么我们需要进行 $\frac{2}{n(n-1)}$ 次元素比较，同样次数的元素移动。</li>
<li>平均时间复杂度：$A(n) \displaystyle \in O(n^2))$</li>
</ul>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>插入排序的核心想法就是<strong>通过元素比较，消除逆序</strong>，这样就达到了排序的目的。而基于比较的排序算法，一次最多只能消除一对逆序关系，这样我们可以知道有多少对逆序，至少需要多少次比较。</p>
<p>n个数据元素，降序有序，是最坏的逆序情况，逆序数量最多有n(n-1)/2个。所以，一个基于比较的排序算法，最坏情况下，需要 n(n-1)/2 次比较。<strong>所以最坏情况时间复杂度A(n)无法再改进了。</strong></p>
<p>平均情况下，一个序列的逆序数量是不确定的，但是我们可以通过构造一个与原序列完全相反的序列，进而计算平均逆序数量。例如：有两个序列 x1 =(2, 4, 1, 5, 3) 和 x2 = (3, 5, 1, 4, 2)，这两个序列总逆序的数量等于 n(n-1)/2，则平均一个序列的逆序数量是 n(n-1)/4 个，那么平均情况也至少需要 n(n-1)/4 次比较操作。<strong>所以平均时间复杂度O(n)也没有将 n^2 降低的可能性。</strong></p>
<p><strong>定理</strong>：任何一个基于关键字的比较且每一次比较最多消除一个逆序的排序算法，最坏的情况下至少比较 n(n-1)/2 次，平均情况至少比较 n(n-1)/4 次。</p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><ul>
<li>将待排序的数据元素的关键字顺次两两比较，若为逆序则将两个数据元素交换</li>
<li><strong>将待排序的数据元素照此方法从头到尾处理一遍称作一趟起泡排序，它将关键字值最大的数据元素交换到排序的最终位置。</strong></li>
<li><strong>若某一趟冒泡排序没发生任何数据元素的交换，则排序过程结束。</strong></li>
<li>对含n个记录的文件排序最多需要n-1趟冒泡排序。</li>
</ul>
<img src = "https://pic1.zhimg.com/v2-7ad20c51bc69abf2c7c436e1cc1b6560_b.webp" alt="img" style="zoom:100%;">



<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>最坏情况：序列是逆序，需要比较的次数为 n(n-1)/2，则对应时间复杂度为 $ W(n) \displaystyle \in O(n^2)$ 。</li>
<li>最好情况：序列已经是升序有序序列，则进行一次比较即可，第一次比较发现没有发生数据移动，则排序结束，比较次数为 n - 1 次，则时间复杂度为 $B(n) \displaystyle \in O(n^2))$ 。</li>
<li>平均情况： $A(n) \displaystyle \in O(n^2))$</li>
</ul>
<h2 id="代码优化-1"><a href="#代码优化-1" class="headerlink" title="代码优化"></a>代码优化</h2><p><strong>优化1：</strong>记下最后一次交换的位置，后边没有交换，必然是有序的，然后下一次排序从第一个比较到上次记录的位置结束即可。同时引入布尔变量 sorted 作为标记，如果在一趟排序中没有交换元素，说明这组数据已经有序，不用再继续下去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> LastExchangeIndex = <span class="number">0</span>;  <span class="comment">//上一次交换位置</span></span><br><span class="line">        <span class="keyword">int</span> border = nums.length-<span class="number">1</span>;  <span class="comment">//无序列表边界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> sorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; border; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                    LastExchangeIndex = j;</span><br><span class="line">                    sorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sorted)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            border = LastExchangeIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化2：</strong>双边界冒泡排序，见《计算机算法——设计与分析导论》习题4.5。以序列(2,3,4,5,1)为例，在普通冒泡排序下，需要盲目比较左侧有序子列，引入左侧边界解决这一问题：找到首个交换位置 pos，则下一趟冒泡排序的起始位置 border_left = pos - 1 or 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;        </span><br><span class="line">        <span class="comment">//双边界冒泡排序</span></span><br><span class="line">        <span class="keyword">int</span> FirstExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> LastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> border_left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> border_right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> sorted_left = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">boolean</span> sorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = border_left; j &lt; border_right; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//记录首个交换的位置</span></span><br><span class="line">                    <span class="keyword">if</span>(sorted_left)&#123;</span><br><span class="line">                        border_left = j-<span class="number">1</span> &gt;= <span class="number">0</span> ? j-<span class="number">1</span>:<span class="number">0</span>;  <span class="comment">//左边界更新</span></span><br><span class="line">                        sorted_left = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    sorted = <span class="keyword">false</span>;</span><br><span class="line">                    LastExchangeIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sorted)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            border_right = LastExchangeIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p><strong>优化3：鸡尾酒排序</strong>，又称双向冒泡排序、搅拌排序。排序过程像钟摆一样，奇数轮从左到右，偶数轮从右到左。示意图如下：</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180527/a94afb3620614bfc9523efcd42c8342a.gif" alt="img"></p>
<p>鸡尾酒排序适用于基本有序的序列。还以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率相当（都为O(n^2) ）。缺点是代码量较大。</p>
<ul>
<li>最差时间复杂度 O(n^2) </li>
<li>最优时间复杂度 O(n)</li>
<li>平均时间复杂度 O(n^2)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> border_right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> border_left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> LastExchangeIndex_right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> LastExchangeIndex_left = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//正向</span></span><br><span class="line">            <span class="keyword">boolean</span> sorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; border_right; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    LastExchangeIndex_right = j;</span><br><span class="line">                    sorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sorted)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            border_right = LastExchangeIndex_right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反向</span></span><br><span class="line">            sorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length-<span class="number">1</span>-i; j &gt; border_left; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                    nums[j-<span class="number">1</span>] = temp;</span><br><span class="line">                    LastExchangeIndex_left = j;</span><br><span class="line">                    sorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sorted)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            border_left = LastExchangeIndex_left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序（二）：分而治之：快速排序 &amp;&amp; 归并排序</title>
    <url>/2021/09/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="排序（二）：分而治之：快速排序-amp-amp-归并排序"><a href="#排序（二）：分而治之：快速排序-amp-amp-归并排序" class="headerlink" title="排序（二）：分而治之：快速排序 &amp;&amp; 归并排序"></a>排序（二）：分而治之：快速排序 &amp;&amp; 归并排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>在待排序的N个记录中任取一个元素(通常取第一个记录)作为基准，称为基准记录；</li>
<li>定义两个索引 left 和 right 分别表示“首索引” 和 “尾索引”，key 表示“基准值”；</li>
<li>首先，尾索引向前扫描，直到找到比基准值小的记录(left != right)，并替换首索引对应的值；</li>
<li>然后，首索引向后扫描，直到找到比基准值大于的记录(left != right)，并替换尾索引对应的值；</li>
<li>若在扫描过程中首索引等于尾索引(left &gt;= right)，则一趟排序结束；将基准值(key)替换首索引所对应的值；</li>
<li>再进行下一趟排序时，待排序列被分成两个区:[0,left-1]，[right+1,end]</li>
<li>对每一个分区重复步骤2~6，直到所有分区中的记录都有序，排序成功。</li>
</ol>
<p>示意图如下：</p>
<p><img src="https://pic3.zhimg.com/v2-40324fb744639dcd983d496289aaf41a_b.webp" alt="img"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        quicksort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)  <span class="comment">//一定要加，否则当left &lt; 0 或 left &gt;= nums.length 时越界</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(nums, left, right);</span><br><span class="line">        quicksort(nums, left, pos-<span class="number">1</span>);</span><br><span class="line">        quicksort(nums, pos+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> base = nums[low];       </span><br><span class="line">        <span class="keyword">int</span> left = low, right = high;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= base)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt; base)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">                nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = base;  </span><br><span class="line">        <span class="keyword">return</span> left;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>内部循环的另一种写法，该方法需要自己编写一个数组元素交换函数 **void swap(int[] nums, int left, int right)**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;right &amp;&amp; nums[right]&gt;=base) right--;  </span><br><span class="line">    <span class="keyword">while</span> (left&lt;right &amp;&amp; nums[left] &lt;=base) left++;    </span><br><span class="line">    <span class="keyword">if</span> (left&lt;right)</span><br><span class="line">        swap(nums,left,right);</span><br><span class="line">&#125;</span><br><span class="line">swap(nums, low, left);</span><br></pre></td></tr></table></figure>



<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最坏情况：最坏情况是序列已经有序，且选取的枢轴是最小的元素，导致划分后的问题规模是 0 和 n-1，然后接下来枢轴仍然是最小值。给出一个例子，”1, 2, 3, 4, 5, 6, 7, 8, 9, 10“，假设每次选取第一个元素作为枢轴，那么这个序列就对应着最坏情况，需要交换 $\frac{2}{n(n-1)}$。时间复杂度为 $W(n) \displaystyle \in O(n^2))$ 。</li>
<li>平均时间复杂度：$A(n) \displaystyle \in O(nlog(n)))$</li>
</ul>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>改进措施：</p>
<ul>
<li>递归：因为递归调用过程是要消耗计算资源的，因此可以改为非递归</li>
<li>小排序问题：对于数量较小的数组，排序可以使用其他排序算法。例如<strong>在 C++的STL库中，sort() 函数在 num &lt; 16 时采用的是插入排序</strong>。</li>
<li>枢轴的选取–随机打乱、随机选择等等方法，一种方法是选择数组首元素、尾元素和中位元素的中位数作为枢轴，防止选到数组中最小元素。</li>
</ul>
<h3 id="快排起始方向的选择问题：为什么一定要从右边开始"><a href="#快排起始方向的选择问题：为什么一定要从右边开始" class="headerlink" title="*快排起始方向的选择问题：为什么一定要从右边开始"></a>*快排起始方向的选择问题：为什么一定要从右边开始</h3><blockquote>
<p>参考链接：<a href="https://blog.csdn.net/he37176427/article/details/97795963">https://blog.csdn.net/he37176427/article/details/97795963</a></p>
</blockquote>
<p><strong>因为选择的基准值key一般都是最左边的元素。</strong></p>
<p>假设左哨兵为i， 右哨兵为j， 选择的 key 为最左边的元素。也就是说，当首先从右边开始先执行时，循环的条件是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= key) j--;</span><br></pre></td></tr></table></figure>

<p>最后 i、j 停留的位置的值一定是要小于 key的，此时交换索引 i 和最左边元素 key 符合将小于 key 的值放到 key 左边这一条件。<strong>比较抽象，可以自己画一下图！</strong></p>
<p>当首先从左边开始执行时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt;= key) i++;</span><br></pre></td></tr></table></figure>

<p>循环结束后的 i、j 停留的位置的大于 key，此时再交换 key 与索引位置 i 相当于把比key大的值放到了 key 左边，违背了快排的条件。</p>
<p>如果想先从左往右查找，只需把 key 设置在右侧即可。</p>
<p>同理，假如想排降序的也要从相反方向开始， 将两个循环条件的 &gt;=、&lt;= 的方向调换即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &lt;= key) j--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &gt;= key) i++;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>归并排序的思想是：将待排序序列划分成若干个有序子序列；将两个或两个以上的有序子序列合并为一个有序序列。</p>
<img src="/images/article/mergesort.jpg" alt="mergesort" style="zoom:50%;" />

<p><strong>归并排序特点：</strong></p>
<ul>
<li>有序子序列的数据元素的个数≤Merge算法的比较次数</li>
<li>Merge算法的比较次数≤2个子序列数据元素个数和-1</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//朴素归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        mergesort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            mergesort(nums, left, mid);</span><br><span class="line">            mergesort(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">            merge(nums, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[j])</span><br><span class="line">                temp[k++] = nums[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right)</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt;= right - left; k++)</span><br><span class="line">            nums[k+left] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>最坏情况：</strong>是最后一次比较两个有序子序列各自剩最后一个数据元素。例如（1,3,5,7）和（2,4,6,8）这个两个子序列合并一共需要比较n-1次，是最坏情况。此时时间复杂度为：$ W(n) \displaystyle \in O(nlogn) $</p>
<p><strong>最优情况：</strong>例如（1,2,3,4）和 (5,6,7,8) 这两个序列，只需要比较 n/2=8/2=4 次即可。此时时间复杂度为：$ B(n) \displaystyle \in O(nlogn) $</p>
<p><strong>平均时间复杂度：</strong>综上，归并排序是一种稳定的排序方法，平均时间复杂度为：$ A(n) \displaystyle \in O(nlogn) $</p>
<h3 id="代码优化-1"><a href="#代码优化-1" class="headerlink" title="代码优化"></a>代码优化</h3><ol>
<li><strong>消除递归：</strong>避免递归过程的时间消耗。</li>
<li><strong>最长无逆序子序列：</strong>我们经过分析知道，归并排序的基础是两个有序子序列的合并，那么我们可以通过寻找最长无逆序子序列来优化归并排序的比较次数。例如，（<strong>4，5，6</strong>，3，7，1）这个序列，我们找到三个无逆序子序列（[4]、[5]、[6]），直接对这三个子序列进行合并，减少比较次数。</li>
<li><strong>小排序问题：</strong>划分为小序列时选用插入排序，合并到较长序列时采用归并排序。</li>
<li><strong>不回写：重点</strong> 一般归并排序存在将备用序列 temp 写回原序列的操作，这种写回操作在大排序问题时非常浪费时间，思考一种不回写策略来解决这个问题。</li>
</ol>
<p><strong>优化一</strong>：<strong>二路归并排序。</strong>化递归为循环。将n个待排序的数据直接划分成n个规模为1的子序列，依次合并两个相邻有序子序列，直到只剩下一个有序子序列为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二路归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[j])</span><br><span class="line">                temp[k++] = nums[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right)</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt;= right - left; k++)</span><br><span class="line">            nums[k+left] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [i, i+len-1], [i+len, i+2*len-1]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n + <span class="number">1</span> - <span class="number">2</span> * len; i = i + <span class="number">2</span> * len) &#123;</span><br><span class="line">                merge2(nums, i, i + len - <span class="number">1</span>, i + <span class="number">2</span> * len - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//剩余两个子列</span></span><br><span class="line">            <span class="keyword">if</span> (i + len - <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                merge2(nums, i, i + len - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//剩余1个子列 </span></span><br><span class="line">            <span class="keyword">else</span>;</span><br><span class="line">            len *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化二：不回写</strong>。奇数趟从原数组 nums[] 写到备用数组 temp[] ，偶数趟从 temp[] 写到 nums[]。如果做了奇数趟，排序结束，则需要将数据从 temp[] 写到 nums[]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge3</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = left;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[j])</span><br><span class="line">                temp[k++] = nums[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right)</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;<span class="comment">//通过flag来判定当前是奇数回合还是偶数回合</span></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> i;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n + <span class="number">1</span> - <span class="number">2</span> * len; i = i + <span class="number">2</span> * len) &#123;</span><br><span class="line">                    merge3(nums, temp, i, i + len - <span class="number">1</span>, i + <span class="number">2</span> * len - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + len - <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    merge3(nums, temp, i, i + len - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; n; i++) temp[i] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                len *= <span class="number">2</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> i;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n + <span class="number">1</span> - <span class="number">2</span> * len; i = i + <span class="number">2</span> * len) &#123;</span><br><span class="line">                    merge3(temp, nums, i, i + len - <span class="number">1</span>, i + <span class="number">2</span> * len - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + len - <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    merge3(temp, nums, i, i + len - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; n; i++) nums[i] = temp[i];</span><br><span class="line">                &#125;</span><br><span class="line">                len *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; n; p++) &#123;</span><br><span class="line">                nums[p] = temp[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP传递字节数据</title>
    <url>/2021/09/19/UDP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP传递数据不要连接，知道对方地址即可。</p>
<h2 id="UDP传递字节数据"><a href="#UDP传递字节数据" class="headerlink" title="UDP传递字节数据"></a>UDP传递字节数据</h2><p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.lesson3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpClientDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个socket</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="comment">// 新建一个包</span></span><br><span class="line">        String msg = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">        <span class="comment">// 确定接受端ip和接口</span></span><br><span class="line">        InetAddress localhost = InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">9000</span>;</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(msg.getBytes(), <span class="number">0</span>, msg.length(), localhost, <span class="number">9000</span>); ;</span><br><span class="line"></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.lesson3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpServerDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建socket</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="comment">//buffer</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        <span class="comment">// getAddress: 返回此InetAddress对象的原始IP地址。 getHostAddress: 返回文本显示中的IP地址字符串。</span></span><br><span class="line">        System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength()));</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP传递字节数据和文件</title>
    <url>/2021/09/19/TCP%E4%B8%8EUDP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP传递字节数据"><a href="#TCP传递字节数据" class="headerlink" title="TCP传递字节数据"></a>TCP传递字节数据</h2><p>在 OutputStream 和 InputStream 的外面套用字节流管道ByteArrayIn(Out)putStream 实现文件的传输。</p>
<p><img src="/images/article/image-20210915104325376.png" alt="image-20210915104325376"></p>
<p><strong>注意：</strong>read()从输入流中读取下一个字节，若没有字节可读（也就是read()读到文件最后了），则返回-1。利用如下代码进行读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.lesson2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 服务器地址</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待客户端连接</span></span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">// 读取消息</span></span><br><span class="line">                is = socket.getInputStream();</span><br><span class="line">                <span class="comment">// 利用管道流实现通讯</span></span><br><span class="line">                baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(baos.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(baos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            略去is、socket、serversocket的关闭</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.lesson2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InetAddress serverIP = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取服务器地址IP、端口号</span></span><br><span class="line">            serverIP = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line">            <span class="comment">// 创建连接</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, port);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;你好，欢迎学习网络编程&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*关闭资源</span></span><br><span class="line"><span class="comment">            略去</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP传递文件"><a href="#TCP传递文件" class="headerlink" title="TCP传递文件"></a>TCP传递文件</h2><p>文件在连接中以字节流形式传递。引入 FileOut(In)putStream.</p>
<p><img src="/images/article/image-20210915104632382.png" alt="image-20210915104632382"></p>
<p><strong>服务端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.lesson2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 服务器连接</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="comment">//  监听</span></span><br><span class="line">        Socket socket = serverSocket.accept(); <span class="comment">//阻塞式监听，会一直等待客户端连接</span></span><br><span class="line">        <span class="comment">// 获取输入流</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 文件输出</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;receive.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println(&quot;OK?&quot;);</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 告知客户端接收完毕</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();  <span class="comment">//如果不关掉连接，服务端始终监听</span></span><br><span class="line">        os.write(<span class="string">&quot;我已经接收完毕了&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        os.close();;</span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.lesson2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 创建链接</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        <span class="comment">// 创建输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 文件流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;test.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">// 写出文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知服务器已经传输完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        <span class="comment">//System.out.println(&quot;Has sent!&quot;);</span></span><br><span class="line">        <span class="comment">//确定服务器接收完毕，断开连接</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len2;</span><br><span class="line">        <span class="keyword">while</span>((len2 = is.read(buffer2)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer2, <span class="number">0</span>, len2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        baos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>IP地址与端口</title>
    <url>/2021/09/19/IP%E5%92%8C%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>IP地址的作用</strong>：唯一定位网络上的计算机。</p>
<p><strong>IP地址分类</strong>：</p>
<p>从网际协议版本上：</p>
<table>
<thead>
<tr>
<th>协议版本</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>IPv4</td>
<td>127.0.0.1<br/>32位，4个字节组成，每个数字范围0~255，约42亿个<br/>2011年已用尽</td>
</tr>
<tr>
<td>IPv6</td>
<td>fe80::f468:b07b:9f96:bdca%2<br/>128位（8个无符号整数）</td>
</tr>
</tbody></table>
<p>从接入方式上：</p>
<table>
<thead>
<tr>
<th>接入方式</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>公网（互联网）</td>
<td>计算机得到的IP地址互联网上的非保留地址</td>
</tr>
<tr>
<td>私网（局域网）</td>
<td>192.168.<em>.</em><br/>指在某一区域内由多台计算机互联成的计算机组，<strong>分为ABCD…类</strong></td>
</tr>
</tbody></table>
<p><strong>域名的作用</strong>：记忆IP</p>
<h2 id="命令行查看IP地址"><a href="#命令行查看IP地址" class="headerlink" title="命令行查看IP地址"></a>命令行查看IP地址</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig  <span class="comment">#查看ip</span></span><br></pre></td></tr></table></figure>

<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>InetAddress：此类表示Internet协议（IP）地址。 <strong>注意：</strong>InetAddress构造方法私有，只能通过其他成员函数新建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试IP</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIDAddress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//getByName:根据提供的主机名和IP地址创建 InetAddress</span></span><br><span class="line">            <span class="comment">//查询本机地址</span></span><br><span class="line">            InetAddress inetAddress1 = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(inetAddress1);</span><br><span class="line">            InetAddress inetAddress2 = InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            System.out.println(inetAddress2);</span><br><span class="line">            InetAddress inetAddress3 = InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(inetAddress3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//查询网络地址</span></span><br><span class="line">            InetAddress inetAddress4 = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">            System.out.println(inetAddress4);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//常用方法</span></span><br><span class="line">            System.out.println(inetAddress4.getAddress());  <span class="comment">//返回此 InetAddress对象的原始IP地址。</span></span><br><span class="line">            System.out.println(inetAddress4.getCanonicalHostName());  <span class="comment">//获取此IP地址的完全限定域名(规范的名字——ip)</span></span><br><span class="line">            System.out.println(inetAddress4.getHostAddress());  <span class="comment">//ip</span></span><br><span class="line">            System.out.println(inetAddress4.getHostName());  <span class="comment">//获取此IP地址的主机名/域名</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>输出结果我们发现：使用 getLocalHost() 方法输出的结果是本机配置的IPv4，而 getByName(“localhost”) 和 getByName(“127.0.0.1”)的输出结果为 127.0.0.1，二者不同。</p>
<p>引出问题：<a href="https://blog.csdn.net/ithover/article/details/78916998?utm_medium=distribute.pc_relevant.none-task-blog-2~default~essearch~vector-6.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~essearch~vector-6.no_search_link">localhost、127.0.0.1 和 本机IP 三者的区别</a></p>
<h3 id="配置映射地址"><a href="#配置映射地址" class="headerlink" title="*配置映射地址"></a>*配置映射地址</h3><p>在C:\Windows\System32\drivers\etc\hosts文件下可以配置127.0.0.1的映射地址。格式示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1	www.baidu.com</span><br></pre></td></tr></table></figure>

<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><h2 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>端口的作用</strong>：区分不同应用进程间的网络通信和连接，规定为0 ~ 65535。TCP/UDP：65535 * 2 ，单个协议下，端口号不能冲突。</p>
<p><strong>通信三要素</strong>：通信的目的IP地址、使用的传输层协议(TCP 或 UDP)和使用的端口号。</p>
<p><strong>端口分类</strong>：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td>公有端口0 ~ 1023</td>
<td align="left">HTTP：80<br/>    HTTPS：443<br/>    FTP：21<br/>    Telent：23</td>
</tr>
<tr>
<td>程序注册端口：1024 ~ 49151<br/>分配给用户或者程序</td>
<td align="left">Tomcat：8080<br/>    MySQL：3306<br/>    Oracle：1512</td>
</tr>
<tr>
<td>动态、私有：49152 ~ 65535</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="命令行查看端口信息"><a href="#命令行查看端口信息" class="headerlink" title="命令行查看端口信息"></a>命令行查看端口信息</h2><p>win+R打开命令行，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano  <span class="comment">#查看所有的端口</span></span><br><span class="line">netstat -ano | findstr <span class="string">&quot;5900&quot;</span>  <span class="comment">#查看指定的端口</span></span><br><span class="line">tasklist | findstr <span class="string">&quot;8696&quot;</span>  <span class="comment">#查看指定端口的进程</span></span><br></pre></td></tr></table></figure>

<h2 id="InetSocketAddress"><a href="#InetSocketAddress" class="headerlink" title="InetSocketAddress"></a>InetSocketAddress</h2><p>InetSocketAddress：该类实现IP套接字地址<em><strong>IP地址+端口号</strong></em>，也可以是<em><strong>主机名+端口号</strong></em>，在这种情况下将尝试解析主机名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInetSocketAddress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">        System.out.println(socketAddress);</span><br><span class="line"></span><br><span class="line">        System.out.println(socketAddress.getAddress());  <span class="comment">//获得 InetAddress / IP地址</span></span><br><span class="line">        System.out.println(socketAddress.getHostName());</span><br><span class="line">        System.out.println(socketAddress.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬取知乎回答并进行舆情分析：舆情分析部分</title>
    <url>/2021/08/27/python_zhihu2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在上一节中，利用爬虫爬取了<a href="https://www.zhihu.com/question/482094335/answer/2080599564"><strong>问题</strong></a>下的所有回答，原文链接如下：<br><a href="http://dutljy.top/2021/08/24/python_zhihu/">python爬取知乎回答并进行舆情分析：爬取数据部分</a><br>本节中利用jieba工具对回答分词，统计词频生成词云，并利用折线图统计每日回答数，做一个简单的舆情分析。</p>
<h1 id="生成词云"><a href="#生成词云" class="headerlink" title="生成词云"></a>生成词云</h1><h2 id="文本预处理（使用停用词、自定义分词）"><a href="#文本预处理（使用停用词、自定义分词）" class="headerlink" title="文本预处理（使用停用词、自定义分词）"></a>文本预处理（使用停用词、自定义分词）</h2><p>jieba分词支持<strong>停用词</strong>和<strong>自定义分词</strong>。停用词能够过滤掉与语义无关的单词，自定义分词能够防止指定词汇被切分，例如某些不被一般词典收纳的新潮词汇。</p>
<p>引包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<p>加载词典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载自定义词典  </span></span><br><span class="line">newdict_path = <span class="string">&quot;./source/newdict.txt&quot;</span></span><br><span class="line">jieba.load_userdict(newdict_path)       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载停用词词典</span></span><br><span class="line">stop_list = []</span><br><span class="line">stopdict_path = <span class="string">&#x27;./source/stopdict.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(stopdict_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        stop_list.append(line[:-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>数据预处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">&#x27;./test.csv&#x27;</span>)</span><br><span class="line">data[<span class="string">&#x27;回答&#x27;</span>] = data[<span class="string">&#x27;回答&#x27;</span>].apply(<span class="keyword">lambda</span> x : x.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) </span><br><span class="line">data[<span class="string">&#x27;回答&#x27;</span>] = data[<span class="string">&#x27;回答&#x27;</span>].apply(<span class="keyword">lambda</span> x : x.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)) </span><br><span class="line">data[<span class="string">&#x27;分词&#x27;</span>] = data[<span class="string">&#x27;回答&#x27;</span>].apply(<span class="keyword">lambda</span> x : [i <span class="keyword">for</span> i <span class="keyword">in</span> jieba.cut(x) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> stop_list])</span><br><span class="line">data[<span class="string">&#x27;创建时间&#x27;</span>] = data[<span class="string">&#x27;创建时间&#x27;</span>].apply(<span class="keyword">lambda</span> x : x[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure>

<h2 id="统计词频"><a href="#统计词频" class="headerlink" title="统计词频"></a>统计词频</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_words = data[<span class="string">&#x27;分词&#x27;</span>].to_list()</span><br><span class="line"></span><br><span class="line">word_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> words <span class="keyword">in</span> all_words:</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> word_dict:</span><br><span class="line">            word_dict[word] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            word_dict[word] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="生成词云-1"><a href="#生成词云-1" class="headerlink" title="生成词云"></a>生成词云</h2><p>利用<strong>wordcloud</strong>绘制词云：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="comment"># 生成词云</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_word_cloud</span>(<span class="params">word_dict</span>):</span></span><br><span class="line">    <span class="comment"># 支持中文, SimHei.ttf可从以下地址下载：https://github.com/cystanford/word_cloud</span></span><br><span class="line">    wc = WordCloud(</span><br><span class="line">        font_path=<span class="string">&quot;./source/SimHei.ttf&quot;</span>,</span><br><span class="line">        background_color=<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">        max_words=<span class="number">25</span>,</span><br><span class="line">        width=<span class="number">1800</span>,</span><br><span class="line">        height=<span class="number">1200</span>,</span><br><span class="line">    )</span><br><span class="line">    word_cloud = wc.generate_from_frequencies(word_dict)</span><br><span class="line">    <span class="comment"># 写词云图片</span></span><br><span class="line">    word_cloud.to_file(<span class="string">&quot;wordcloud2.jpg&quot;</span>)</span><br><span class="line">    <span class="comment"># 显示词云文件</span></span><br><span class="line">    plt.imshow(word_cloud)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据词频生成词云</span></span><br><span class="line">create_word_cloud(word_dict)</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://img-blog.csdnimg.cn/5e9215aee694425fa89325e3a8a4484d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5peg6ZmQ5LmL6Zi_5bCU5rOV,size_10,color_FFFFFF,t_70,g_se,x_16,#pic_center" alt="在这里插入图片描述"></p>
<h1 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h1><h2 id="统计每日回答数"><a href="#统计每日回答数" class="headerlink" title="统计每日回答数"></a>统计每日回答数</h2><p>利用字典统计每日回答的数量。：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修正回答时间格式：年-月-日 </span></span><br><span class="line">data[<span class="string">&#x27;创建时间&#x27;</span>] = data[<span class="string">&#x27;创建时间&#x27;</span>].apply(<span class="keyword">lambda</span> x : x[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">date_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">all_dates = data[<span class="string">&#x27;创建时间&#x27;</span>].to_list()</span><br><span class="line"><span class="keyword">for</span> date <span class="keyword">in</span> all_dates:</span><br><span class="line">    <span class="keyword">if</span> date <span class="keyword">not</span> <span class="keyword">in</span> date_dict:</span><br><span class="line">        date_dict[date] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        date_dict[date] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> date_dict.items():</span><br><span class="line">    x.append(key)</span><br><span class="line">    y.append(value)</span><br></pre></td></tr></table></figure>

<h2 id="生成折线图"><a href="#生成折线图" class="headerlink" title="生成折线图"></a>生成折线图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">#通用设置，背景颜色、图片大小、是否</span></span><br><span class="line">matplotlib.rc(<span class="string">&#x27;axes&#x27;</span>, facecolor = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">matplotlib.rc(<span class="string">&#x27;figure&#x27;</span>, figsize = (<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">matplotlib.rc(<span class="string">&#x27;axes&#x27;</span>, grid = <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#数据及线属性</span></span><br><span class="line">plt.plot(x, y,<span class="string">&#x27;.-&#x27;</span>)</span><br><span class="line"><span class="comment">#标题设置</span></span><br><span class="line">plt.title(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;amount&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://img-blog.csdnimg.cn/9b3c93065a6640d7a8453a52d0b08a03.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5peg6ZmQ5LmL6Zi_5bCU5rOV,size_10,color_FFFFFF,t_70,g_se,x_16,#pic_center" alt="在这里插入图片描述"></p>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>除了<strong>回答</strong>和<strong>创建时间</strong>两个字段以外，爬取结果的其他字段也可以进行数据分析；也可以尝试利用user_token做一个用户画像分析。</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬取知乎回答并进行舆情分析：爬取数据部分</title>
    <url>/2021/08/24/python_zhihu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>近期导师让我从社交媒体平台（包括微博、知乎、贴吧等）爬取用户评论数据，并进行相应的舆情分析。之前爬取过贴吧和微博的数据，这次第一回接触知乎的爬虫，发现还是有区别的。写篇博客记录一下~</p>
<h1 id="Ajax原理介绍"><a href="#Ajax原理介绍" class="headerlink" title="Ajax原理介绍"></a>Ajax原理介绍</h1><p>利用google浏览器打开知乎中任意问题（本文中示例问题为 <a href="https://www.zhihu.com/question/482094335/answer/2080599564"><strong>如何看待天府少年团改名熊猫少儿艺术团，公司称「不做饭圈文化，没有资本运作，爱舞台的孩子做有意义的事」？</strong></a>），发现知乎采取动态加载技术，内容块只有在浏览器下滚时才会刷新。与微博和贴吧不同，知乎的html文件中没有“下一页”的相关节点，无法直接解析。因此需要从原始的Request报文着手，获取文本数据。</p>
<p><strong>Ajax</strong>(Asynchronous Java and XML的缩写)是一种异步请求数据的web开发技术，能够改善用户的体验，提高页面性能。</p>
<p>Ajax的工作原理相当于在用户和服务器之间加了—个中间层(<strong>XHR</strong>)，使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给XHR自己来做, 只有确定需要从服务器读取新数据时再由XHR代为向服务器提交请求，示意图如下：<br><img src="https://img-blog.csdnimg.cn/3bca656242a84d8298a4ff0bd00e5545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDgwNjA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">在本次爬虫中，利用Ajax技术获取服务器发往浏览器的原始报文。</p>
<h1 id="Request-URL分析"><a href="#Request-URL分析" class="headerlink" title="Request URL分析"></a>Request URL分析</h1><p>F12进入开发者模式，进入<strong>Network</strong>界面，选择<strong>Fetch/XML</strong>，可以看到各个请求的相关信息。<br><img src="https://img-blog.csdnimg.cn/47792da2a6624b3fbdd1e40154b74437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDgwNjA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">选择其中answers?开头的请求，观察<strong>Request URL</strong>。注意到有两个字段，<strong>offset</strong> 和 <strong>limit</strong>，其中 <strong>offset</strong> 指的是报文中第一个回答对应的索引号（从0开始），<strong>limit</strong> 指的是一条报文中能够包含的最多的回答数。用户可以在URL定义这两个值。</p>
<p><strong>在设定时应当注意</strong>：<br>offset 不能超过回答总数 - 1；<br>limit 不能超过上限。<br><img src="https://img-blog.csdnimg.cn/f1643c2ade5e471d8c2ef3c485af50ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDgwNjA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">为了便于观察json数据报格式，将 limit 设定为1，复制以下URL即可查看json报文信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">https://www.zhihu.com/api/v4/questions/<span class="number">482094335</span>/answers?include=data%5B*%5D.is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cattachment%2Cvoteup_count%2Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Crelevant_info%2Cquestion%2Cexcerpt%2Cis_labeled%2Cpaid_info%2Cpaid_info_content%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked%2Cis_nothelp%2Cis_recognized%3Bdata%5B*%5D.mark_infos%5B*%5D.url%3Bdata%5B*%5D.author.follower_count%2Cvip_info%2Cbadge%5B*%5D.topics%3Bdata%5B*%5D.settings.table_of_content.enabled&amp;offset=<span class="number">0</span>&amp;limit=<span class="number">1</span>&amp;sort_by=default&amp;platform=desktop</span><br></pre></td></tr></table></figure>

<h1 id="json报文结构分析"><a href="#json报文结构分析" class="headerlink" title="json报文结构分析"></a>json报文结构分析</h1><p>下面对json报文进行结构分析，报文主要分为两部分：<strong>“data”</strong> 和 <strong>“page”</strong>。<br>data：包含 html 文本数据，本次爬虫重点关注以下字段：</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">author -&gt; name</td>
<td align="center">用户名</td>
</tr>
<tr>
<td align="center">author -&gt; url_token</td>
<td align="center">用户token</td>
</tr>
<tr>
<td align="center">content</td>
<td align="center">回答</td>
</tr>
<tr>
<td align="center">updated_time</td>
<td align="center">回答时间</td>
</tr>
<tr>
<td align="center">voteup_count</td>
<td align="center">赞同数量</td>
</tr>
<tr>
<td align="center">comment_count</td>
<td align="center">评论数量</td>
</tr>
</tbody></table>
<p><strong>说明：</strong><br><strong>用户token是用户的唯一识别标志</strong>，“<a href="https://www.zhihu.com/people/%E2%80%9D">https://www.zhihu.com/people/”</a> + url_token 为该用户知乎主页；<br><strong>报文中的时间都是时间戳</strong>，需要转化为 “年-月-日 时-分-秒” 的形式。</p>
<p>page：记录是否已经是该问题下的最后一个回答。如果字段 <strong>is_end = true</strong>，则可以结束请求。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>引包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> codecs <span class="comment">#解决乱码</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br></pre></td></tr></table></figure>

<p>请求头和URL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Request URL</span></span><br><span class="line">base_url = <span class="string">&quot;https://www.zhihu.com/api/v4/questions/482094335/answers?&quot;</span></span><br><span class="line">include = <span class="string">&quot;data%5B%2A%5D.is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cattachment%2Cvoteup_count%2Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Crelevant_info%2Cquestion%2Cexcerpt%2Cis_labeled%2Cpaid_info%2Cpaid_info_content%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked%2Cis_nothelp%2Cis_recognized%3Bdata%5B%2A%5D.mark_infos%5B%2A%5D.url%3Bdata%5B%2A%5D.author.follower_count%2Cvip_info%2Cbadge%5B%2A%5D.topics%3Bdata%5B%2A%5D.settings.table_of_content.enabled&quot;</span></span><br></pre></td></tr></table></figure>
<p>获得页面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获得页面</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span>(<span class="params">offset</span>):</span></span><br><span class="line">    page_url = <span class="string">&#x27;include=&#x27;</span> + include + <span class="string">&#x27;&amp;limit=5&amp;&#x27;</span> + <span class="string">&#x27;offset=&#x27;</span> + <span class="built_in">str</span>(offset) + <span class="string">&#x27;&amp;platform=desktop&amp;sort_by=default&#x27;</span></span><br><span class="line">    url = base_url + page_url</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>, e.args)</span><br></pre></td></tr></table></figure>
<p>时间转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 时间戳转化为年-月-日 时-分-秒</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TimeStampToTime</span>(<span class="params">timestamp</span>):</span></span><br><span class="line">    timeStruct = time.localtime(timestamp)</span><br><span class="line">    <span class="keyword">return</span> time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, timeStruct)</span><br></pre></td></tr></table></figure>
<p>解析页面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解析网页</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span>(<span class="params">json</span>):</span></span><br><span class="line">    <span class="keyword">if</span> json:</span><br><span class="line">        items = json.get(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:  <span class="comment"># items: 一条报文中的所有回答 </span></span><br><span class="line">            zhihu = &#123;&#125;</span><br><span class="line">            zhihu[<span class="string">&#x27;作者&#x27;</span>] = item.get(<span class="string">&#x27;author&#x27;</span>).get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">            zhihu[<span class="string">&#x27;user_token&#x27;</span>] = item.get(<span class="string">&#x27;author&#x27;</span>).get(<span class="string">&#x27;url_token&#x27;</span>)</span><br><span class="line">            zhihu[<span class="string">&#x27;回答&#x27;</span>] = pq(item.get(<span class="string">&#x27;content&#x27;</span>)).text()</span><br><span class="line">            zhihu[<span class="string">&#x27;创建时间&#x27;</span>] = TimeStampToTime(item.get(<span class="string">&#x27;updated_time&#x27;</span>))</span><br><span class="line">            zhihu[<span class="string">&#x27;赞同数&#x27;</span>] = item.get(<span class="string">&#x27;voteup_count&#x27;</span>)</span><br><span class="line">            zhihu[<span class="string">&#x27;评论数&#x27;</span>] = item.get(<span class="string">&#x27;comment_count&#x27;</span>)</span><br><span class="line">            <span class="keyword">yield</span> zhihu</span><br></pre></td></tr></table></figure>
<p>主函数执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    i = <span class="number">0</span>  </span><br><span class="line">    f = codecs.<span class="built_in">open</span>(<span class="string">&#x27;test.csv&#x27;</span>, <span class="string">&#x27;w+&#x27;</span>, <span class="string">&#x27;utf_8_sig&#x27;</span>)</span><br><span class="line">    f_txt = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w+&#x27;</span>, encoding=<span class="string">&#x27;utf_8&#x27;</span>)</span><br><span class="line">    fieldnames = [<span class="string">&#x27;作者&#x27;</span>, <span class="string">&#x27;user_token&#x27;</span>, <span class="string">&#x27;回答&#x27;</span>, <span class="string">&#x27;创建时间&#x27;</span>, <span class="string">&#x27;赞同数&#x27;</span>, <span class="string">&#x27;评论数&#x27;</span>]</span><br><span class="line">    writer = csv.DictWriter(f, fieldnames=fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        js = get_page(i*<span class="number">5</span>)  <span class="comment"># 根据报文首个回答对应的索引值获取页面</span></span><br><span class="line">        results = parse_page(js)</span><br><span class="line">        <span class="keyword">for</span> res <span class="keyword">in</span> results:</span><br><span class="line">            writer.writerow(res)</span><br><span class="line">            <span class="keyword">for</span> detail <span class="keyword">in</span> res.values():</span><br><span class="line">                f_txt.write(<span class="built_in">str</span>(detail) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            f_txt.write(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;*&#x27;</span> * <span class="number">50</span> + <span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># 分隔符</span></span><br><span class="line">        <span class="keyword">if</span> js.get(<span class="string">&#x27;paging&#x27;</span>).get(<span class="string">&#x27;is_end&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;finish!&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    f.close()</span><br><span class="line">    f_txt.close()</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/m0_37969932/article/details/116330217?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162969083416780261967528%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162969083416780261967528&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-116330217.ecpm_v1_rank_v29&utm_term=%E7%9F%A5%E4%B9%8E%E7%88%AC%E8%99%AB&spm=1018.2226.3001.4187">2021年知乎爬虫</a></p>
<p><a href="https://blog.csdn.net/weixin_45019310/article/details/89923644?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162977091516780255228188%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162977091516780255228188&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-89923644.pc_search_download_positive&utm_term=%E7%9F%A5%E4%B9%8Eajax&spm=1018.2226.3001.4187">python爬虫——关于ajax加载之爬取2019年知乎问题和描述</a></p>
<p><a href="https://www.sohu.com/a/238246281_100109711">Ajax原理</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/23/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>博客相关</tag>
      </tags>
  </entry>
</search>
